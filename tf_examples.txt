ALTERACAO BRANCH FEAT1

COMPANHEIRO ALTERANDO...

aws_set_credentials.sh
======================
#!/bin/bash

# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Creates AWS credentials from an accessKeys.csv file.

# May need to create the accessKeys.csv file from arguments.
# arguments: key_id access_key key_file
function createAccessKeys() {
  echo 'Access key ID,Secret access key' > "$3"
  echo "$1,$2" >> "$3"
  echo "Created $3."
}


# Check arguments for existing accessKeys.csv file.
# arguments: named_key_csv_file
function checkArgs () {
  local FILE_ARG='<path to csv accessKeys file>'

  if [ -z "$1" ]; then
    echo 'Error: missing argument.'
    echo "$0 ${FILE_ARG}"
    exit 1
  fi

  if [ "$1" != "exists" ] && [ ! -e "$1" ]; then
    echo 'Error: file not found.'
    echo "$0 ${FILE_ARG}"
    exit 1
  fi
}


# Backup existing credentials and create new ones.
# arguments: source_credentials_file target_file_path
function backupCredentials() {
  local BACKUP_FILE="$2.bak.$(date +%s)"
  if [ -e $1.bak ]; then
    cp "$2" "${BACKUP_FILE}"
    echo "Created backup (${BACKUP_FILE})."
  fi

  cp "$1" "$1.bak"
  echo "Created backup ($1.bak)."
}


# Start the new file with [default]
# arguments: credentials_file
function addDefault() {
  echo '[default]' > $1
}


# Add AWS secrets.
# arguments: source_keys_file credentials_file
function addSecrets() {
  local KEY_ID=$(tail -1 "$1" | cut -d"," -f1)
  local SECRET_KEY=$(tail -1 "$1" | cut -d"," -f2)

  echo "aws_access_key_id=${KEY_ID}" >> $2
  echo "aws_secret_access_key=${SECRET_KEY}" >> $2

  echo "Created $2."
}


# Start a new terraform.tfvars file.
# arguments: full_path_file_name.
function createTFVars() {
  if [ ! -e $1 ]; then
    echo "/*" > $1
    echo " * Initialized Terraform variables." >> $1
    echo " */" >> $1
  fi
}


# If not already present, add a key-value to tfvars file.
# arguments: tfvars_path_file_name key value
function addTFVar() {
  if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
    echo 'Error: missing argument for addTFVar().'
    exit 1
  fi

  local VAR_NAME="$2"
  local KEY_EXISTS="$(cat $1 | grep $2)"

  if [ -z "${KEY_EXISTS}" ]; then
    echo "" >> $1
    echo "$2 = \"$3\"" >> $1
    echo "Updated $2 in $1."
  fi
}


# Create fresh AWS credentials file.
# arguments: named_key_csv_file
function createCredentials () {
  # ~ only expands when NOT quoted (below).
  local CREDS_FILE_DIR=~/.aws
  local CREDS_FILE_PATH="${CREDS_FILE_DIR}/credentials_multiclouddeploy"
  local THIS_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  local TFVARS_DIR_PATH="${THIS_DIR}/terraform"
  local TFVARS_FILE_PATH="${TFVARS_DIR_PATH}/terraform.tfvars"
  local TFVAR_CREDS='aws_credentials_file_path'

  if [ "$1" != "exists" ]; then
    mkdir -p ${CREDS_FILE_DIR}
    backupCredentials ${CREDS_FILE_PATH} ${CREDS_FILE_PATH}
    addDefault ${CREDS_FILE_PATH}
    addSecrets $1 ${CREDS_FILE_PATH}
  fi

  createTFVars "${TFVARS_FILE_PATH}"
  addTFVar "${TFVARS_FILE_PATH}" "${TFVAR_CREDS}" "${CREDS_FILE_PATH}"
}

if [ "$#" -eq 0 ]; then
  echo 'Error: missing argument.'
  echo "$0 ${FILE_ARG}"
  exit 1
fi

ACCESS_KEYS_FILE=$1

if [ "$#" -eq 2 ]; then
  ACCESS_KEYS_FILE=./accessKeys.csv
  createAccessKeys $1 $2 ${ACCESS_KEYS_FILE}
fi

checkArgs ${ACCESS_KEYS_FILE}
# Pass "exists" to skip credential file copying.
createCredentials ${ACCESS_KEYS_FILE}

=========================================================================================================
gcp_set_credentials.sh
========================
#!/bin/bash

# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Add GCP credentials path to configuration defaults file.

# Check arguments for existing json key file.
# arguments: <project-id>-<unique-id>.json
function checkArgs () {
  local FILE_ARG='<path to json service account key file>'

  if [ -z "$1" ]; then
    echo 'Error: missing argument.'
    echo "$0 ${FILE_ARG}"
    exit 1
  fi

  if [ "$1" != "exists" ] && [ ! -e "$1" ]; then
    echo 'Error: file not found.'
    echo "$0 ${FILE_ARG}"
    exit 1
  fi
}


# Backup existing credentials and create new ones.
# arguments: source_credentials_file target_file_path
function backupAndCopyCredentials() {
  local BACKUP_FILE="$2.bak.$(date +%s)"
  if [ -e $2 ]; then
    cp "$2" "${BACKUP_FILE}"
    echo "Created backup (${BACKUP_FILE})."
  fi

  cp "$1" "$2"
  echo "Created $2 from $1."
}


# Start a new terraform.tfvars file.
# arguments: full_path_file_name.
function createTFVars() {
  if [ ! -e $1 ]; then
    echo "/*" > $1
    echo " * Initialized Terraform variables." >> $1
    echo " */" >> $1
  fi
}


# If not already present, add a key-value to tfvars file.
# arguments: tfvars_path_file_name key value
function addTFVar() {
  if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
    echo 'Error: missing argument for addTFVar().'
    exit 1
  fi

  local VAR_NAME="$2"
  local KEY_EXISTS="$(cat $1 | grep $2)"

  if [ -z "${KEY_EXISTS}" ]; then
    echo "" >> $1
    echo "$2 = \"$3\"" >> $1
    echo "Updated $2 in $1."
  fi
}


# Create fresh GCP credentials file and point Terraform at it.
# arguments: <project-id>-<unique-id>.json
function createCredentials () {
  # ~ only expands when NOT quoted (below).
  local CREDS_FILE_DIR=~/.config/gcloud
  local CREDS_FILE_PATH="${CREDS_FILE_DIR}/credentials_multiclouddeploy.json"
  local THIS_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  local TFVARS_DIR_PATH="${THIS_DIR}/terraform"
  local TFVARS_FILE_PATH="${TFVARS_DIR_PATH}/terraform.tfvars"
  local TFVAR_CREDS='gcp_credentials_file_path'

  if [ "$1" != "exists" ]; then
    mkdir -p ${CREDS_FILE_DIR}
    backupAndCopyCredentials $1 ${CREDS_FILE_PATH}
  fi

  createTFVars "${TFVARS_FILE_PATH}"
  addTFVar "${TFVARS_FILE_PATH}" "${TFVAR_CREDS}" "${CREDS_FILE_PATH}"
}


# Copy/create file under ~/.config/gcloud
checkArgs $1
# Pass "exists" to skip credential file copying.
createCredentials $1

===================================================================================================
gcp_set_project.sh
====================
#!/bin/bash

# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Add GCP project to configuration files.

# Check function arguments for project.
# arguments: project
function checkArgs () {
  if [ -z "$1" ]; then
    echo "Error: missing argument. $0 <GCP project_id>"
    exit 1
  fi
}


# Update project_id in DM config file.
# arguments: project_id dm_project_file
function fixDMProject() {
  local DM_PROJECT_FILE="${2}"
  local SED_EX="s/project_id: .*/project_id: $1/"
  sed -i -e "${SED_EX}" ${DM_PROJECT_FILE}
  echo "Updated project_id: ${1} in ${DM_PROJECT_FILE}."
}


# Start a new terraform.tfvars file.
# arguments: full_path_file_name.
function createTFVars() {
  if [ ! -e $1 ]; then
    echo "/*" > $1
    echo " * Initialized Terraform variables." >> $1
    echo " */" >> $1
  fi
}


# If not already present, add a key-value to tfvars file.
# arguments: tfvars_path_file_name key value
function addTFVar() {
  if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
    echo 'Error: missing argument for addTFVar().'
    exit 1
  fi

  local VAR_NAME="$2"
  local KEY_EXISTS="$(cat $1 | grep $2)"

  if [ -z "${KEY_EXISTS}" ]; then
    echo "" >> $1
    echo "$2 = \"$3\"" >> $1
    echo "Updated $2 in $1."
  fi
}


# Add projects to configuration file(s) if existing.
# arguments: project
function addProject() {
  local PROJECT_ID="$1"
  local THIS_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  local DM_PROJECT_FILE='autonetdeploy_config.yaml'
  local DM_PROJECT_FILE_PATH="${THIS_DIR}/deploymentmanager/${DM_PROJECT_FILE}"
  local TFVARS_DIR_PATH="${THIS_DIR}/terraform"
  local TFVARS_FILE_PATH="${TFVARS_DIR_PATH}/terraform.tfvars"
  local TFVAR_PROJECT='gcp_project_id'

  checkArgs ${PROJECT_ID}

  if [ -e ${DM_PROJECT_FILE_PATH} ]; then
    fixDMProject ${PROJECT_ID} ${DM_PROJECT_FILE_PATH}
  fi

  # Always create terraform.tfvars file even if dir does not exist already.
  mkdir -p "${TFVARS_DIR_PATH}"
  createTFVars "${TFVARS_FILE_PATH}"
  addTFVar "${TFVARS_FILE_PATH}" "${TFVAR_PROJECT}" "${PROJECT_ID}"
}

addProject $(gcloud config get-value project 2> /dev/null)

===================================================================================================

get_terraform.sh
================
#!/bin/bash

# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Download Terraform utility.

# Download and extract Terraform utility in the terraform directory.
function getTerraform() {
  # Places terraform in ~/terraform dir.
  local T_VERSION='0.12.4/terraform_0.12.4_linux_amd64'
  local T_URL="https://releases.hashicorp.com/terraform/${T_VERSION}.zip"
  # ~ only expands when NOT quoted (below).
  local T_DIR=~/terraform
  local T_ZIP="${T_DIR}/terraform.zip"
  local T_EXE="${T_DIR}/terraform"

  if [ -e ${T_EXE} ]; then
    echo "${T_EXE} already exists. Exiting."
    echo ''
    echo "To adjust your path: export PATH=${T_DIR}:\${PATH}"
    exit 0
  fi

  mkdir -p ${T_DIR}
  pushd ${T_DIR} > /dev/null
  curl -o "${T_ZIP}" "${T_URL}"
  unzip -q "${T_ZIP}"
  rm "${T_ZIP}"
  popd > /dev/null

  if [ -e ${T_EXE} ]; then
    echo "Successfully retrieved ${T_EXE}."
    echo ''
    echo "To adjust your path: export PATH=${T_DIR}:\${PATH}"
  else
    echo "Could not retrieve ${T_EXE}."
  fi
}

getTerraform

=================================================================================================
=================================================================================================
-rw-rw-r-- 1 luciano_david luciano_david  1747 Oct  2  2023 aws_compute.tf
-rw-rw-r-- 1 luciano_david luciano_david  2544 Jun 29  2022 aws_networking.tf
-rw-rw-r-- 1 luciano_david luciano_david   802 Feb  5  2021 aws_outputs.tf
-rw-rw-r-- 1 luciano_david luciano_david  2069 Feb  5  2021 aws_security.tf
-rw-rw-r-- 1 luciano_david luciano_david  1498 Oct  2  2023 aws_variables.tf
-rw-rw-r-- 1 luciano_david luciano_david  1654 Aug 13 23:02 gcp_compute.tf
-rw-rw-r-- 1 luciano_david luciano_david  8769 Jun 29  2022 gcp_networking.tf
-rw-rw-r-- 1 luciano_david luciano_david   890 Jun 29  2022 gcp_outputs.tf
-rw-rw-r-- 1 luciano_david luciano_david  2000 Feb  5  2021 gcp_security.tf
-rw-rw-r-- 1 luciano_david luciano_david  2223 Aug 13 23:12 gcp_variables.tf
-rw-rw-r-- 1 luciano_david luciano_david  1288 Nov 14  2023 main.tf
-rw-rw-r-- 1 luciano_david luciano_david   181 Aug 13 23:41 terraform.tfstate
-rw-rw-r-- 1 luciano_david luciano_david 99052 Aug 13 23:39 terraform.tfstate.backup
-rw-rw-r-- 1 luciano_david luciano_david   267 Aug 13 22:00 terraform.tfvars
-rw-rw-r-- 1 luciano_david luciano_david  1214 Feb  4  2021 vm_userdata.sh

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat aws_compute.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform compute resources for AWS.
 */

data "aws_ami" "ubuntu" {
  most_recent = true

  filter {
    name   = "name"
    values = [var.aws_disk_image]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }

  owners = ["amazon"] # Canonical
}

resource "aws_eip" "aws-ip" {
  vpc = true

  instance                  = aws_instance.tcb-aws-vm-01.id
  associate_with_private_ip = var.aws_vm_address
}

resource "aws_instance" "tcb-aws-vm-01" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = var.aws_instance_type
  subnet_id     = aws_subnet.tcb-aws-subnet1.id
  key_name      = "vm-ssh-key"

  associate_public_ip_address = true
  private_ip                  = var.aws_vm_address

  vpc_security_group_ids = [
    aws_security_group.aws-allow-icmp.id,
    aws_security_group.aws-allow-ssh.id,
    aws_security_group.aws-allow-vpn.id,
    aws_security_group.aws-allow-internet.id,
  ]

  user_data = replace(
    replace(
      file("vm_userdata.sh"),
      "<EXT_IP>",
      google_compute_address.gcp-ip.address,
    ),
    "<INT_IP>",
    var.gcp_vm_address,
  )

  tags = {
    Name = "tcb-aws-vm-01"
  }
}

**************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat aws_networking.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform networking resources for AWS.
 */

resource "aws_vpc" "tcb-aws-vpc" {
  cidr_block           = var.aws_network_cidr
  enable_dns_support   = true
  enable_dns_hostnames = true
  tags = {
    "Name" = "tcb-aws-vpc"
  }
}

resource "aws_subnet" "tcb-aws-subnet1" {
  vpc_id     = aws_vpc.tcb-aws-vpc.id
  cidr_block = var.aws_subnet1_cidr

  tags = {
    Name = "tcb-aws-subnet1"
  }
}

resource "aws_internet_gateway" "aws-vpc-igw" {
  vpc_id = aws_vpc.tcb-aws-vpc.id

  tags = {
    Name = "aws-vpc-igw"
  }
}

/*
 * ----------VPN Connection----------
 */

resource "aws_vpn_gateway" "aws-vpn-gw" {
  vpc_id = aws_vpc.tcb-aws-vpc.id
}

resource "aws_customer_gateway" "aws-cgw-1" {
  bgp_asn    = 65000
  ip_address = google_compute_ha_vpn_gateway.gcp-vpn-gw.vpn_interfaces[0].ip_address
  type       = "ipsec.1"
  tags = {
    "Name" = "aws-customer-gw"
  }
}

resource "aws_customer_gateway" "aws-cgw-2" {
  bgp_asn    = 65000
  ip_address = google_compute_ha_vpn_gateway.gcp-vpn-gw.vpn_interfaces[1].ip_address
  type       = "ipsec.1"
  tags = {
    "Name" = "aws-customer-gw"
  }
}

resource "aws_default_route_table" "tcb-aws-vpc" {
  default_route_table_id = aws_vpc.tcb-aws-vpc.default_route_table_id
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.aws-vpc-igw.id
  }
  propagating_vgws = [
    aws_vpn_gateway.aws-vpn-gw.id,
  ]
}

resource "aws_vpn_connection" "aws-vpn-connection1" {
  vpn_gateway_id      = aws_vpn_gateway.aws-vpn-gw.id
  customer_gateway_id = aws_customer_gateway.aws-cgw-1.id
  type                = "ipsec.1"
  static_routes_only  = false
  tags = {
    "Name" = "aws-vpn-connection1"
  }
}

resource "aws_vpn_connection" "aws-vpn-connection2" {
  vpn_gateway_id      = aws_vpn_gateway.aws-vpn-gw.id
  customer_gateway_id = aws_customer_gateway.aws-cgw-2.id
  type                = "ipsec.1"
  static_routes_only  = false
  tags = {
    "Name" = "aws-vpn-connection2"
  }
}

***************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat aws_outputs.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform output variables for AWS.
 */

output "aws_instance_external_ip" {
  value = aws_eip.aws-ip.public_ip
}

output "aws_instance_internal_ip" {
  value = aws_instance.tcb-aws-vm-01.private_ip
}

*****************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat aws_security.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform security (firewall) resources for AWS.
 */

# Allow PING testing.
resource "aws_security_group" "aws-allow-icmp" {
  name        = "aws-allow-icmp"
  description = "Allow icmp access from anywhere"
  vpc_id      = aws_vpc.tcb-aws-vpc.id

  ingress {
    from_port   = 8
    to_port     = 0
    protocol    = "icmp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Allow SSH for iperf testing.
resource "aws_security_group" "aws-allow-ssh" {
  name        = "aws-allow-ssh"
  description = "Allow ssh access from anywhere"
  vpc_id      = aws_vpc.tcb-aws-vpc.id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Allow traffic from the VPN subnets.
resource "aws_security_group" "aws-allow-vpn" {
  name        = "aws-allow-vpn"
  description = "Allow all traffic from vpn resources"
  vpc_id      = aws_vpc.tcb-aws-vpc.id

  ingress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = [var.gcp_subnet1_cidr]
  }
}

# Allow TCP traffic from the Internet.
resource "aws_security_group" "aws-allow-internet" {
  name        = "aws-allow-internet"
  description = "Allow http traffic from the internet"
  vpc_id      = aws_vpc.tcb-aws-vpc.id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

*************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat aws_variables.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform variable declarations for AWS.
 */

variable "aws_credentials_file_path" {
  description = "Locate the AWS credentials file."
  type        = string
}

variable "aws_region" {
  description = "Default to Oregon region."
  default     = "us-west-2"
}

variable "aws_instance_type" {
  description = "Machine Type. Includes 'Enhanced Networking' via ENA."
  default     = "t3.micro"
}

variable "aws_disk_image" {
  description = "Boot disk for gcp_instance_type."
  default     = "ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"
}

variable "aws_network_cidr" {
  description = "VPC network ip block."
  default     = "172.16.0.0/16"
}

variable "aws_subnet1_cidr" {
  description = "Subset block from VPC network ip block."
  default     = "172.16.0.0/24"
}

variable "aws_vm_address" {
  description = "Private IP address for AWS VM instance."
  default     = "172.16.0.100"
}

*************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat gcp_compute.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform compute resources for GCP.
 * Acquire all zones and choose one randomly.
 */

data "google_compute_zones" "available" {
  region = var.gcp_region
}

resource "google_compute_address" "gcp-ip" {
  name   = "gcp-vm-ip"
  region = var.gcp_region
}

resource "google_compute_instance" "tcb-gcp-vm-01" {
  name         = "tcb-gcp-vm-01"
  machine_type = var.gcp_instance_type
  zone         = data.google_compute_zones.available.names[0]

  boot_disk {
    initialize_params {
      image = var.gcp_disk_image
    }
  }

  network_interface {
    subnetwork = google_compute_subnetwork.tcb-gcp-subnet1.name
    network_ip = var.gcp_vm_address

    access_config {
      # Static IP
      nat_ip = google_compute_address.gcp-ip.address
    }
  }

  # Cannot pre-load both gcp and aws since that creates a circular dependency.
  # Can pre-populate the AWS IPs to make it easier to run tests.
  metadata_startup_script = replace(
    replace(file("vm_userdata.sh"), "<EXT_IP>", aws_eip.aws-ip.public_ip),
    "<INT_IP>",
    var.aws_vm_address,
  )
}

***********************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat gcp_networking.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform networking resources for GCP.
 */

resource "google_compute_network" "tcb-gcp-network" {
  name                    = "tcb-gcp-network"
  auto_create_subnetworks = "false"
}

resource "google_compute_subnetwork" "tcb-gcp-subnet1" {
  name          = "tcb-gcp-subnet1"
  ip_cidr_range = var.gcp_subnet1_cidr
  network       = google_compute_network.tcb-gcp-network.name
  region        = var.gcp_region
}

/*
 * ----------VPN Connection----------
 */

resource "google_compute_ha_vpn_gateway" "gcp-vpn-gw" {
  name    = "gcp-vpn-gw-${var.gcp_region}"
  network = google_compute_network.tcb-gcp-network.name
  region  = var.gcp_region
}

resource "google_compute_external_vpn_gateway" "external_gateway" {
  name            = "aws-gateway"
  redundancy_type = "FOUR_IPS_REDUNDANCY"
  description     = "Dual AWS VPN gateways"
  interface {
    id         = 0
    ip_address = aws_vpn_connection.aws-vpn-connection1.tunnel1_address
  }
  interface {
    id         = 1
    ip_address = aws_vpn_connection.aws-vpn-connection1.tunnel2_address
  }
  interface {
    id         = 2
    ip_address = aws_vpn_connection.aws-vpn-connection2.tunnel1_address
  }
  interface {
    id         = 3
    ip_address = aws_vpn_connection.aws-vpn-connection2.tunnel2_address
  }  
}

/*
 * ----------VPN Tunnel1----------
 */

resource "google_compute_vpn_tunnel" "gcp-tunnel1" {
  name                            = "gcp-tunnel1"
  peer_external_gateway           = google_compute_external_vpn_gateway.external_gateway.id
  peer_external_gateway_interface = 0
  shared_secret                   = aws_vpn_connection.aws-vpn-connection1.tunnel1_preshared_key
  ike_version                     = 2
  vpn_gateway                     = google_compute_ha_vpn_gateway.gcp-vpn-gw.self_link
  router                          = google_compute_router.gcp-router1.name
  vpn_gateway_interface           = 0
}

resource "google_compute_router" "gcp-router1" {
  name    = "gcp-router1"
  region  = var.gcp_region
  network = google_compute_network.tcb-gcp-network.name
  bgp {
    asn = aws_customer_gateway.aws-cgw-1.bgp_asn
  }
}

resource "google_compute_router_peer" "gcp-router1-peer" {
  name            = "gcp-to-aws-bgp1"
  router          = google_compute_router.gcp-router1.name
  region          = google_compute_router.gcp-router1.region
  peer_ip_address = aws_vpn_connection.aws-vpn-connection1.tunnel1_vgw_inside_address
  peer_asn        = var.GCP_TUN1_VPN_GW_ASN
  interface       = google_compute_router_interface.router_interface1.name
}

resource "google_compute_router_interface" "router_interface1" {
  name       = "gcp-to-aws-interface1"
  router     = google_compute_router.gcp-router1.name
  region     = google_compute_router.gcp-router1.region
  ip_range   = "${aws_vpn_connection.aws-vpn-connection1.tunnel1_cgw_inside_address}/${var.GCP_TUN1_CUSTOMER_GW_INSIDE_NETWORK_CIDR}"
  vpn_tunnel = google_compute_vpn_tunnel.gcp-tunnel1.name
}

/*
 * ----------VPN Tunnel2----------
 */

resource "google_compute_vpn_tunnel" "gcp-tunnel2" {
  name                            = "gcp-tunnel2"
  peer_external_gateway           = google_compute_external_vpn_gateway.external_gateway.id
  peer_external_gateway_interface = 1
  shared_secret                   = aws_vpn_connection.aws-vpn-connection1.tunnel2_preshared_key
  ike_version                     = 2
  vpn_gateway                     = google_compute_ha_vpn_gateway.gcp-vpn-gw.self_link
  router                          = google_compute_router.gcp-router2.name
  vpn_gateway_interface           = 0
}

resource "google_compute_router" "gcp-router2" {
  name    = "gcp-router2"
  region  = var.gcp_region
  network = google_compute_network.tcb-gcp-network.name
  bgp {
    asn = aws_customer_gateway.aws-cgw-2.bgp_asn
    advertise_mode    = "CUSTOM"
    advertised_groups = ["ALL_SUBNETS"]    
  }
}

resource "google_compute_router_peer" "gcp-router2-peer" {
  name            = "gcp-to-aws-bgp2"
  router          = google_compute_router.gcp-router2.name
  region          = google_compute_router.gcp-router2.region
  peer_ip_address = aws_vpn_connection.aws-vpn-connection1.tunnel2_vgw_inside_address
  peer_asn        = var.GCP_TUN2_VPN_GW_ASN
  interface       = google_compute_router_interface.router_interface2.name
}

resource "google_compute_router_interface" "router_interface2" {
  name       = "gcp-to-aws-interface2"
  router     = google_compute_router.gcp-router2.name
  region     = google_compute_router.gcp-router2.region
  ip_range   = "${aws_vpn_connection.aws-vpn-connection1.tunnel2_cgw_inside_address}/${var.GCP_TUN2_CUSTOMER_GW_INSIDE_NETWORK_CIDR}"
  vpn_tunnel = google_compute_vpn_tunnel.gcp-tunnel2.name
}

 /* ----------VPN Tunnel3----------
 */
resource "google_compute_vpn_tunnel" "gcp-tunnel3" {
  name                            = "gcp-tunnel3"
  peer_external_gateway           = google_compute_external_vpn_gateway.external_gateway.id
  peer_external_gateway_interface = 2
  shared_secret                   = aws_vpn_connection.aws-vpn-connection2.tunnel1_preshared_key
  ike_version                     = 2
  vpn_gateway                     = google_compute_ha_vpn_gateway.gcp-vpn-gw.self_link
  router                          = google_compute_router.gcp-router3.name
  vpn_gateway_interface           = 1
}

resource "google_compute_router" "gcp-router3" {
  name    = "gcp-router3"
  region  = var.gcp_region
  network = google_compute_network.tcb-gcp-network.name
  bgp {
    asn = aws_customer_gateway.aws-cgw-2.bgp_asn
    advertise_mode    = "CUSTOM"
    advertised_groups = ["ALL_SUBNETS"]
  }
}

resource "google_compute_router_peer" "gcp-router3-peer" {
  name            = "gcp-to-aws-bgp3"
  router          = google_compute_router.gcp-router3.name
  region          = google_compute_router.gcp-router3.region
  peer_ip_address = aws_vpn_connection.aws-vpn-connection2.tunnel1_vgw_inside_address
  peer_asn        = var.GCP_TUN1_VPN_GW_ASN
  interface       = google_compute_router_interface.router_interface3.name
}

resource "google_compute_router_interface" "router_interface3" {
  name       = "gcp-to-aws-interface3"
  router     = google_compute_router.gcp-router3.name
  region     = google_compute_router.gcp-router3.region
  ip_range   = "${aws_vpn_connection.aws-vpn-connection2.tunnel1_cgw_inside_address}/${var.GCP_TUN1_CUSTOMER_GW_INSIDE_NETWORK_CIDR}"
  vpn_tunnel = google_compute_vpn_tunnel.gcp-tunnel3.name
}

/* ----------VPN Tunnel4----------
 */
resource "google_compute_vpn_tunnel" "gcp-tunnel4" {
  name                            = "gcp-tunnel4"
  peer_external_gateway           = google_compute_external_vpn_gateway.external_gateway.id
  peer_external_gateway_interface = 3
  shared_secret                   = aws_vpn_connection.aws-vpn-connection2.tunnel2_preshared_key
  ike_version                     = 2
  vpn_gateway                     = google_compute_ha_vpn_gateway.gcp-vpn-gw.self_link
  router                          = google_compute_router.gcp-router4.name
  vpn_gateway_interface           = 1
}

resource "google_compute_router" "gcp-router4" {
  name    = "gcp-router4"
  region  = var.gcp_region
  network = google_compute_network.tcb-gcp-network.name
  bgp {
    asn = aws_customer_gateway.aws-cgw-2.bgp_asn
    advertise_mode    = "CUSTOM"
    advertised_groups = ["ALL_SUBNETS"]
  }
}

resource "google_compute_router_peer" "gcp-router4-peer" {
  name            = "gcp-to-aws-bgp4"
  router          = google_compute_router.gcp-router4.name
  region          = google_compute_router.gcp-router4.region
  peer_ip_address = aws_vpn_connection.aws-vpn-connection2.tunnel2_vgw_inside_address
  peer_asn        = var.GCP_TUN2_VPN_GW_ASN
  interface       = google_compute_router_interface.router_interface4.name
}

resource "google_compute_router_interface" "router_interface4" {
  name       = "gcp-to-aws-interface4"
  router     = google_compute_router.gcp-router4.name
  region     = google_compute_router.gcp-router4.region
  ip_range   = "${aws_vpn_connection.aws-vpn-connection2.tunnel2_cgw_inside_address}/${var.GCP_TUN2_CUSTOMER_GW_INSIDE_NETWORK_CIDR}"
  vpn_tunnel = google_compute_vpn_tunnel.gcp-tunnel4.name
}

*****************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat gcp_outputs.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform output variables for GCP.
 */

output "gcp_instance_external_ip" {
  value = google_compute_instance.tcb-gcp-vm-01.network_interface[0].access_config[0].nat_ip
}

output "gcp_instance_internal_ip" {
  value = google_compute_instance.tcb-gcp-vm-01.network_interface[0].network_ip
}

********************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat gcp_security.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform security (firewall) resources for GCP.
 */

# Allow PING testing.
resource "google_compute_firewall" "gcp-allow-icmp" {
  name    = "${google_compute_network.tcb-gcp-network.name}-gcp-allow-icmp"
  network = google_compute_network.tcb-gcp-network.name

  allow {
    protocol = "icmp"
  }

  source_ranges = [
    "0.0.0.0/0",
  ]
}

# Allow SSH for iperf testing.
resource "google_compute_firewall" "gcp-allow-ssh" {
  name    = "${google_compute_network.tcb-gcp-network.name}-gcp-allow-ssh"
  network = google_compute_network.tcb-gcp-network.name

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = [
    "0.0.0.0/0",
  ]
}

# Allow traffic from the VPN subnets.
resource "google_compute_firewall" "gcp-allow-vpn" {
  name    = "${google_compute_network.tcb-gcp-network.name}-gcp-allow-vpn"
  network = google_compute_network.tcb-gcp-network.name

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = [
    var.aws_subnet1_cidr,
  ]
}

# Allow TCP traffic from the Internet.
resource "google_compute_firewall" "gcp-allow-internet" {
  name    = "${google_compute_network.tcb-gcp-network.name}-gcp-allow-internet"
  network = google_compute_network.tcb-gcp-network.name

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = [
    "0.0.0.0/0",
  ]
}

************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat gcp_variables.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform variable declarations for GCP.
 */

variable "gcp_credentials_file_path" {
  description = "Locate the GCP credentials .json file."
  type        = string
}

variable "gcp_project_id" {
  description = "GCP Project ID."
  type        = string
}

variable "gcp_region" {
  description = "Default to Oregon region."
  default     = "us-west1"
}

variable "gcp_instance_type" {
  description = "Machine Type. Correlates to an network egress cap."
  default     = "e2-micro"
}

variable "gcp_disk_image" {
  description = "Boot disk for gcp_instance_type."
  default     = "projects/ubuntu-os-cloud/global/images/family/ubuntu-2204-lts"
}

variable "gcp_network_cidr" {
  default = "10.88.0.0/16"
}

variable "gcp_subnet1_cidr" {
  default = "10.88.0.0/24"
}

variable "gcp_vm_address" {
  description = "Private IP address for GCP VM instance."
  default     = "10.88.0.100"
}

variable "GCP_TUN1_VPN_GW_ASN" {
  description = "Tunnel 1 - Virtual Private Gateway ASN, from the AWS VPN Customer Gateway Configuration"
  default     = "64512"
}

variable "GCP_TUN1_CUSTOMER_GW_INSIDE_NETWORK_CIDR" {
  description = "Tunnel 1 - Customer Gateway from Inside IP Address CIDR block, from AWS VPN Customer Gateway Configuration"
  default     = "30"
}

variable "GCP_TUN2_VPN_GW_ASN" {
  description = "Tunnel 2 - Virtual Private Gateway ASN, from the AWS VPN Customer Gateway Configuration"
  default     = "64512"
}

variable "GCP_TUN2_CUSTOMER_GW_INSIDE_NETWORK_CIDR" {
  description = "Tunnel 2 - Customer Gateway from Inside IP Address CIDR block, from AWS VPN Customer Gateway Configuration"
  default     = "30"
}

*******************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat main.tf 
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Terraform main configuration file (with provider definitions).
 */

terraform {
  required_providers {
      aws = {
          source = "hashicorp/aws"
          version = "4.10.0"
      }
      google = {
          source = "hashicorp/google"
            version = "4.18.0"
      }
  }
}

provider "google" {

  credentials = file(var.gcp_credentials_file_path)

  # Should be able to parse project from credentials file but cannot.
  # Cannot convert string to map and cannot interpolate within variables.
  project = var.gcp_project_id

  region = var.gcp_region
}

provider "aws" {

  shared_credentials_files = [pathexpand(var.aws_credentials_file_path)]

  region = var.aws_region
}

**************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat terraform.tfvars 
/*
 * Initialized Terraform variables.
 */

gcp_credentials_file_path = "/home/luciano_david/.config/gcloud/credentials_multiclouddeploy.json"

aws_credentials_file_path = "/home/luciano_david/.aws/credentials_multiclouddeploy"

gcp_project_id = "tcb-gcp-aws-468920"

**************************************************************************************************

luciano_david@cloudshell:~/hands-on-tcb-bmc-gcp/terraform (tcb-gcp-aws-468920)$ cat vm_userdata.sh 
#!/bin/bash -xe

# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Make it easy to run iperf3.
echo "iperf3 -c <EXT_IP> -p 80 -i 1 -t 30 -P 8 -V" > /tmp/run_iperf_to_ext.sh
chmod 755 /tmp/run_iperf_to_ext.sh
echo "iperf3 -c <INT_IP> -p 80 -i 1 -t 30 -P 8 -V" > /tmp/run_iperf_to_int.sh
chmod 755 /tmp/run_iperf_to_int.sh

# Setup iperf3.
apt-get update
apt-get install -y iperf3

cat > /etc/systemd/system/iperf3.service <<EOF
[Unit]
Description=iPerf 3 Server
[Service]
Restart=always
TimeoutStartSec=0
RestartSec=3
WorkingDirectory=/tmp
ExecStart=/usr/bin/iperf3 -s -p 80
[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable iperf3
systemctl start iperf3
